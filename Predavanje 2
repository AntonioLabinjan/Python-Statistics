# Prije djela 2.1.2 nema programskih kodova

# R
Pogledajmo kako bismo u R-u napravili iste tablice i prikazali podatke grafički. Prvo ćemo prevesti tablicu s originalno dobivenim podacima u R data frame, kojeg ćemo nazvati "krgrupa".

Spol <- c("Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž")
Krvna_grupa <- c("A", "0", "B", "0", "0", "A", "AB", "0", "A", "A")
krgrupa <- data.frame(Spol, Krvna_grupa)

Nakon stvaranja data frame-a, tablica "krgrupa" izgleda ovako: 
   Spol Krvna_grupa
1     Ž           A
2     M           0
3     M           B
4     Ž           0
5     Ž           0
6     M           A
7     M          AB
8     Ž           0
9     M           A
10    Ž           A

Sada možemo analizirati podatke. Prvo ćemo upotrijebiti funkciju "table()" kako bismo izradili tablicu koja prikazuje broj pojavnosti svake vrijednosti u jednom od varijabli. 
Na primjer, ako želimo saznati koliko puta se pojavljuju "M" i "Ž" u varijabli "Spol":

table(krgrupa$Spol)

Isto tako, možemo koristiti funkciju "table()" kako bismo izradili tablicu koja prikazuje broj pojavnosti svake krvne grupe u varijabli "Krvna_grupa":

table(krgrupa$Krvna_grupa)

Rezultat će biti:
 0  A AB  B 
 4  4  1  1 

# Python
U Pythonu možemo koristiti Pandas

import pandas as pd

data = {
    'Spol': ["Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž"],
    'Krvna_grupa': ["A", "0", "B", "0", "0", "A", "AB", "0", "A", "A"]
}

krgrupa = pd.DataFrame(data)
print(krgrupa)

# R
Uočili smo da smo izostavili prvi stupac u gornjoj tablici. Koristit ćemo proširenu funkciju "table()" kako bismo dobili broj pojavljivanja svake vrijednosti u pojedinim varijablama.
Također, koristit ćemo "table(krgrupa$Spol)" kako bismo dobili broj muškaraca i žena u našem uzorku te razmotrili odnos frekvencija pojavljivanja vrijednosti "M" i "Ž".

 table(krgrupa$Spol)                                                                                                                                                         
           M              Ž                                                                                                                                                                                   
           5                5

# Python
U Pythonu možemo koristiti Pandas za ostvarivanje istih funkcionalnosti
import pandas as pd

data = {
    'Spol': ["Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž"],
    'Krvna_grupa': ["A", "0", "B", "0", "0", "A", "AB", "0", "A", "A"]
}

krgrupa = pd.DataFrame(data)

# Koristimo value_counts() za izračun frekvencije pojavljivanja svake vrijednosti u stupcu 'Spol'
spol_counts = krgrupa['Spol'].value_counts()

print(spol_counts)

Ovaj Python kod koristi funkciju value_counts() za izračun frekvencije pojavljivanja svake vrijednosti u stupcu 'Spol' u DataFrame-u "krgrupa". Nakon izvođenja koda, dobit ćete rezultat koji prikazuje frekvenciju pojave "M" i "Ž".

# R
Na sljedeći način možemo prikazati frekvenciju pojavljivanja pojedinih krvnih grupa među osobama za koje su dostavljeni podaci:

table(krgrupa$Krvna_grupa)

Rezultat će biti:
  0   A  AB   B 
  4   4   1   1

Kako su nam podaci spremljeni u dataframeove možemo dobiti i zajednički tablični pregled danih podataka po spolu i krvnoj grupi

table(krgrupa)Krvna_grupaSpol 

          Krvna_grupa
Spol       0  A  AB  B
   M       1  2   1  1
   Ž       3  2   0  0

# Python
U Pythonu možemo dobiti ekvivalent koristeći pandas
import pandas as pd

data = {
    'Spol': ["Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž"],
    'Krvna_grupa': ["A", "0", "B", "0", "0", "A", "AB", "0", "A", "A"]
}

krgrupa = pd.DataFrame(data)

# Tablični pregled po krvnoj grupi
krvna_grupa_table = pd.crosstab(krgrupa['Krvna_grupa'], krgrupa['Spol'])

print(krvna_grupa_table)

Spol       M  Ž
Krvna_grupa      
0           1  3
A           2  2
AB          1  0
B           1  0

# R
Tablice relativnih frekvencija za krvne grupe dobivamo tako da frekvenciju pojedinih krvnih grupa dijelimo s ukupnim brojem dostupnih podataka. Možemo definirati novu varijablu "relk" kako slijedi:

relk <- krgrupa$Krvna_grupa / nrow(krgrupa)

Onda možemo primijeniti funkciju "table" kako bismo dobili tablicu relativnih frekvencija, no možemo i jednostavnije:

table(krgrupa$Krvna_grupa) / nrow(krgrupa)

Rezultat će izgledati ovako:
   0      A   AB    B 
  0.4    0.4  0.1   0.1

# Python
Tablice relativnih frekvencija za krvne grupe dobivamo tako da frekvenciju pojedinih krvnih grupa dijelimo s ukupnim brojem dostupnih podataka. Koristit ćemo biblioteku Pandas
import pandas as pd

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Izračun relativnih frekvencija za krvne grupe
relk = krgrupa['Krvna_grupa'].value_counts() / len(krgrupa)

print(relk)

Ovaj Python kod koristi funkciju value_counts() i dijeli rezultate s ukupnim brojem dostupnih podataka kako bi dobio relativne frekvencije krvnih grupa.

0      0.4
A      0.4
AB     0.1
B      0.1
Name: Krvna_grupa, dtype: float64

# R
U nekim situacijama, koristimo svojstvo R-a da možemo vršiti operacije nad jedinstvenim elementima objekta, a to je korisno kada radimo s tablicama. 
U ovom slučaju, uočavamo da R u svojoj osnovnoj verziji ispisuje tablice horizontalno. Međutim, ponekad je preglednije ispisati tablice vertikalno. Kako bi olakšali ovaj zadatak i poboljšali prikaz tablica, možemo koristiti paket "plyr".

library("plyr")
count(krgrupa, "Krvna_grupa")

Ovaj kod koristi "plyr" paket kako bi ispisao tablicu vertikalno, prikazujući frekvenciju svake krvne grupe. Rezultat će izgledati ovako:

  Krvna_grupa freq
1           0    4
2           A    4
3          AB    1
4           B    1

Ovako ćemo dobiti pregledniji prikaz frekvencija krvnih grupa u tablici "krgrupa".

# Python
U  Pythonu se ponovno koristi Pandas
import pandas as pd

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Koristimo funkciju value_counts() za dobivanje frekvencije svake krvne grupe
frekvencije = krgrupa['Krvna_grupa'].value_counts().reset_index()
frekvencije.columns = ['Krvna_grupa', 'freq']

print(frekvencije)

Ovaj Python kod koristi value_counts() da dobije frekvenciju svake krvne grupe i zatim koristi reset_index() i columns kako bi formatirao tablicu. 
Nakon izvođenja koda, dobit ćete ekvivalentan pregled frekvencija krvnih grupa kao što ste imali u R-u:

  Krvna_grupa  freq
0           0     4
1           A     4
2          AB     1
3           B     1

# R
S obzirom na to da postoji drugi paket, poput Display, koji omogućava dodatno prilagođavanje tabličnog prikaza, možemo koristiti njegove funkcionalnosti kako bismo bolje prilagodili prikaz tablica.
Nakon toga, korištenjem osnovne R funkcije barplot(), možemo vizualizirati tablicu frekvencija krvnih grupa. 
Na taj način, tablicu frekvencija krvnih grupa možemo prikazati jednostavnom grafikonom, kao što je prikazano na donjoj slici. 
Kao i kod drugih funkcija za grafički prikaz podataka, možemo prilagoditi parametre slike kako bismo kontrolirali izgled grafikona. U slučaju prikaza frekvencija krvnih grupa, možemo smanjiti veličinu fonta ili promijeniti naziv grafa na "Stupčasti prikaz frekvencija krvnih grupa".

par(mar=c(2,2,2,1))
barplot(table(krgrupa$Krvna_grupa),
        main="Stupčasti prikaz frekvencije krvnih grupa",
        cex.axis=0.7,
        cex.names=0.7,
        cex.main=0.7)

# Python
U Pythonu ćemo koristiti Pandas i Matplotlib za grafički prikaz podataka:
import pandas as pd
import matplotlib.pyplot as plt

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Kreiranje grafikona stupčaste frekvencije
plt.figure(figsize=(6, 4))  # Postavljanje veličine grafikona
plt.bar(krgrupa['Krvna_grupa'].value_counts().index, krgrupa['Krvna_grupa'].value_counts(), color='skyblue')
plt.title("Stupčasti prikaz frekvencije krvnih grupa")  # Naslov grafikona
plt.xlabel("Krvna grupa")  # X-osa
plt.ylabel("Broj osoba")  # Y-osa
plt.xticks(rotation=0)  # Rotacija oznaka na X-osi
plt.tight_layout()

plt.show()  # Prikaz grafikona


# R
S vremena na vrijeme, osim tablice relativnih frekvencija, prikazivanje tablice kumulativnih relativnih frekvencija može biti relevantno. Tablicu kumulativnih relativnih frekvencija možemo jednostavno stvoriti koristeći jednu od osnovnih R-ovih funkcija, cumsum, koja izračunava kumulativni zbroj danog niza elemenata. Da ne bude zabune, ako imamo brojeve 1, 3 i 5, onda je kumulativni zbroj prvih dva broja 4, dok je kumulativni zbroj svih tri broja 9.

Primjer tablice kumulativnih relativnih frekvencija za krvne grupe (prema prethodnim podacima) je naveden u nastavku:

cumsum(table(krgrupa$Krvna_grupa) / nrow(krgrupa))

Ova tablica govori da 40% ispitanika ima krvnu grupu 0, 80% ispitanika ima krvnu grupu 0 ili A, te 90% ispitanika ima barem jednu od krvnih grupa 0, A ili B.
0          A          AB             B
0.4           0.8           0.9           1.0

# Python
Python kod pandas za izračun kumulativnih relativnih frekvencija i stvara DataFrame s kumulativnim frekvencijama. Nakon izvođenja koda, dobit ćemo ekvivalentnu tablicu kumulativnih relativnih frekvencija kao što smo imali u R-u
import pandas as pd

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Izračun kumulativnih relativnih frekvencija
relative_frequencies = krgrupa['Krvna_grupa'].value_counts(normalize=True).sort_index()
cumulative_frequencies = relative_frequencies.cumsum()

# Dodajte kumulativne relativne frekvencije u novi stupac 'Cumulative_Freq'
cumulative_frequencies_df = pd.DataFrame(cumulative_frequencies, columns=['Cumulative_Freq'])

print(cumulative_frequencies_df)

  Cumulative_Freq
0              0.4
A              0.8
AB             0.9
B              1.0

# R
Pogledajmo podatke o visini, težini i indeksu tjelesne težine koje smo vidjeli na kraju prošlog poglavlja. Učitat ćemo ih korištenjem funkcije 
read.xlsx i spremiti u varijablu kvant
# Učitavanje potrebnih biblioteka
library("rJava")
library("xlsx")
library("xlsxjars")

# Učitavanje kvantitativnih podataka iz Excel datoteke
kvant <- read.xlsx("BMI2.xlsx", sheetName = "Druga", header = TRUE, endRow = 13)

# Uklanjanje prvog stupca (Ime) jer nije potreban
kvant <- kvant[, c(2, 3, 4, 5)]

# Provjera tipova preostalih podataka
str(kvant)

Podsjetimo se o kojim je podacima riječ
> kvant
Ovdje su primjeri podataka iz kvantitativnih podataka:

NA|   Ime  |  Težina |  Visina |   BMI   |
  |--------|---------|---------|----------|
  |   A    |    60   |   165   | 22.038572|
  |   B    |    80   |   180   | 24.69136 |
  |   C    |    85   |   175   | 27.755104|
  |   D    |    84   |   184   | 24.810965|
  |   E    |    62   |   168   | 21.967126|
  |   F    |    65   |   175   | 21.224497|
  |   G    |    86   |   184   | 25.401708|
  |   H    |    86   |   192   | 23.328999|
  |   I    |    95   |   182   | 28.68011 |
  |   J    |    78   |   178   | 24.61810 |
  |   K    |    70   |   175   | 22.85714 |
  |   L    |    68   |   170   | 23.52941 |
Vidimo da je prva kolona zapravo višak, a pritom je i bez imena. Možemo je izbrisati tako da varijabli kvant pridružimo sve vrijednosti osim onih iz prve kolone:

kvant<-kvant[,c(2,3,4,5)]
Provjerimo kojeg su tipa preostali podaci: str(kvat)

'data.frame': 12 obs. of 4 variables:
 $ Ime  : chr  "A" "B" "C" "D" ...
 $ Težina: num  60 80 85 84 62 65 86 86 95 78 ...
 $ Visina: num  165 180 175 184 168 175 184 192 182 178 ...
 $ BMI  : num  22 24.7 27.8 24.8 22 ...

Kao i u slučaju kvalitativnih podataka, lako možemo napraviti tablice frekvencija za kvantitativne podatke, na primjer, pojavljivanje različitih visina među osobama čije smo podatke dobili:

table(kvant$Visina)

Rezultat će izgledati ovako:
165 168 170 175 178 180 182 184 192 
1   1   1     3   1   1   1   2   1 

Naravno, jasno je da se visina 175 javlja najčešće, ali u ovom slučaju to nije toliko zanimljivo. Kada se radi s kvantitativnim podacima, imamo mnogo više informacija koje možemo koristiti prilikom analize podataka. Prije svega, to uključuje mjeru središnje tendencije i mjeru raspršenosti podataka.

Vratit ćemo se BMI podacima kako bismo definirali navedene pojmove.

# PYTHON
U Pythonu se ekvivalentni kod može napraviti korsiteći Pandas:
import pandas as pd

# Učitavanje kvantitativnih podataka iz Excel datoteke
kvant = pd.read_excel("BMI2.xlsx", sheet_name="Druga", header=0, nrows=13)

# Izbacivanje prvog stupca (Ime) jer nije potreban
kvant = kvant.iloc[:, 1:]

# Ispis tipova preostalih podataka
print(kvant.dtypes)

# Prikaz tablice frekvencija visine
visina_counts = kvant['Visina'].value_counts()
print(visina_counts)

# DIO 2.2 NE SADRŽI NIKAKVE PROGRAMSKE DJELOVE
# 2.2.1
# R
Aritmetička sredina, mod i medijan
# R
U sljedećem primjeru imamo implementiranu R funkciju mean() koja računa aritmetičku sredinu:
x <- c(24, 5, 9, 12, 22, 2, 89, 4, 13)
mean(x)[1]  # 20

Kao što je dobro poznato, aritmetička sredina računa srednju vrijednost dostupnih vrijednosti iz niza podataka, a ova mjera pomaže u eliminaciji izvanrednih i ekstremnih vrijednosti (outliers). 
U ovom konkretnom primjeru, ukoliko uklonimo vrijednost 89 iz niza podataka, aritmetička sredina se smanjuje na 11.375, što se može postići sljedećim koracima:

x <- x[!x == 89]
mean(x)[1]  # 11.375

# PYTHON
U Pythonu koristimo ugrađenu funkciju mean iz NumPy-a
import numpy as np

x = np.array([24, 5, 9, 12, 22, 2, 89, 4, 13])
result = np.mean(x)
print(result)  # Output: 20.0

# Uklanjanje vrijednosti 89 i ponovno računanje aritmetičke sredine
x = x[x != 89]

result = np.mean(x)
print(result)  # Output: 11.375

# R medijan
Medijan je statistička mjera središnje tendencije koja predstavlja srednju vrijednost unutar poretka podataka.
U R-u, medijan se može izračunati pomoću funkcije median(). Evo primjera i objašnjenja kako se koristi medijan:

# Primjer izračunavanja medijana
# Prvo, koristimo ugrađenu funkciju median() za izračun medijana za cijeli niz podataka
median(c(24, 5, 9, 12, 22, 2, 89, 4, 13))[1]  # Output: 12

# Ako uklonimo vrijednost 89 iz niza 'x' i ponovno izračunamo medijan, dobivamo:
median(x)[1]  # Output: 10.5

U ovom primjeru, medijan originalnog niza (24, 5, 9, 12, 22, 2, 89, 4, 13) iznosi 12. Nakon što izbacimo vrijednost 89 i ponovno izračunamo medijan, dobivamo medijan vrijednosti 10.5.

Medijan je koristan za mjerenje središnje tendencije, a posebno je koristan kada imate outliers (ekstremne vrijednosti) u vašim podacima, jer neće biti toliko osjetljiv na te ekstremne vrijednosti kao aritmetička sredina. 
Medijan je vrijednost koja dijeli vaše podatke na dvije jednake polovice, tako da je polovina vaših podataka manja od medijana, a polovina veća.

# Python medijan
U Pythonu koristimo funkciju median() iz biblioteke NumPy za izračun medijana. Prvo, izračunavamo medijan za originalni niz podataka, a zatim izračunavamo medijan za niz x nakon što smo iz njega izbacili vrijednost 89.

import numpy as np

# Primjer izračunavanja medijana
# Prvo, koristimo funkciju median() iz biblioteke NumPy za izračun medijana za cijeli niz podataka
data = [24, 5, 9, 12, 22, 2, 89, 4, 13]
median_value = np.median(data)
print(median_value)  # Output: 12.0

# Ako uklonimo vrijednost 89 iz niza 'x' i ponovno izračunamo medijan, dobivamo:
x = [value for value in x if value != 89]
median_x = np.median(x)
print(median_x)  # Output: 10.5

#R mod
Mod je statistička mjera koja predstavlja vrijednost koja se najčešće pojavljuje u nizu brojeva. Da bismo izračunali mod niza brojeva u R-u, koristimo funkciju table() za stvaranje tablice frekvencija svakog broja u nizu, a zatim koristimo funkciju names() kako bismo dobili vrijednosti koje imaju najveću frekvenciju. No, primijetimo da su vrijednosti koje vraća names() u obliku znakova (character), pa ih trebamo pretvoriti u numerički format kako bismo dobili mod. Slijedi R kod koji to obavlja:
# Stvaranje uzorka brojeva
nuz <- c(1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9)

# Izračunavanje moda niza brojeva
mod_values <- as.numeric(names(table(nuz))[table(nuz) == max(table(nuz))])
print(mod_values)

# Python mod
U Pythonu mod možemo izračunati pomoću biblioteke statistics:

import statistics

# Stvaranje uzorka brojeva
nuz = [1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9]

# Izračunavanje moda niza brojeva
mod_values = statistics.multimode(nuz)
print(mod_values)

Ovaj kod koristi funkciju multimode() iz statistics biblioteke kako bi pronašao sve vrijednosti koje se pojavljuju najčešće u nizu. Rezultat će sadržavati sve takve mod vrijednosti koje se pojavljuju u nizu nuz

Postoji alternativni način, pomoću numpyja:

import numpy as np

# Stvaranje uzorka brojeva
nuz = np.array([1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9])

# Pronalazak mod vrijednosti
unique_values, counts = np.unique(nuz, return_counts=True)
max_count = np.max(counts)
mod_values = unique_values[counts == max_count]
print(mod_values)

# R
U R-u se mogu definirati vlastite korisnički definirane funkcije. U donjem primjeru, definirana je jednostavna funkcija Mod(), koja ima jedan argument i računa mod numeričkog vektora:
Mod <- function(x) {
  as.numeric(names(table(x))[table(x) == max(table(x))])
}

Ova funkcija uzima vektor x kao ulazni argument. Prvo koristi funkciju table(x) kako bi izračunala frekvenciju pojavljivanja svake vrijednosti u vektoru. Zatim koristi names() kako bi dobila imena (vrijednosti) koje imaju maksimalnu frekvenciju. Konačno, pretvara rezultat u numerički format pomoću as.numeric().

Primjer korištenja funkcije:

nuz <- c(1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9)
mod_result <- Mod(nuz)
print(mod_result)

# Python
U Pythonu, također možemo korisnički definirati funkciju za mod. To možemo napraviti na slijedeći način: 
import numpy as np

def mod(x):
    unique, counts = np.unique(x, return_counts=True)
    max_count = np.max(counts)
    mode_values = unique[counts == max_count]
    return mode_values

nuz = np.array([1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9])
mod_result = mod(nuz)
print(mod_result)

# R
Razmatramo pojmove središnje tendencije i raspršenosti podataka u statistici. Središnja tendencija je mjera koja opisuje centralnu ili tipičnu vrijednost u skupu podataka, dok je raspršenost mjera koja opisuje varijaciju podataka i koliko su raznolike vrijednosti.

Razmotrimo primjer s nizovima podataka:

Prvi niz podataka: 8, 9, 9, 10, 10, 10, 10, 11, 11, 12
Drugi niz podataka: 1, 2, 5, 8, 10, 10, 12, 15, 18, 19

Prvi niz podataka je prilično koncentriran oko vrijednosti 10, što ukazuje na malu raspršenost podataka. Drugi niz podataka je znatno raznolikiji, što znači da ima veću raspršenost.

Unatoč razlici u raspršenosti, i aritmetička sredina i medijan oba niza podataka su 10. To nas podsjeća da iako te mjere pružaju informacije o središnjoj tendenciji, ne govore nam ništa o raspršenosti podataka. Da bismo bolje razumjeli podatke, trebamo razmotriti i druge statističke mjere koje opisuju raspršenost, kao što su varijanca i standardna devijacija.

uski <- c(8, 9, 9, 10, 10, 10, 10, 11, 11, 12)
siroki <- c(1, 2, 5, 8, 10, 10, 12, 15, 18, 19)

mean(uski) # 10
mean(siroki) # 10

median(uski) # 10
median(siroki) # 10

Mod(uski) # 10
Mod(siroki) # 10

# PYTHON
import statistics

uski = [8, 9, 9, 10, 10, 10, 10, 11, 11, 12]
siroki = [1, 2, 5, 8, 10, 10, 12, 15, 18, 19]

mean_uski = statistics.mean(uski)
mean_siroki = statistics.mean(siroki)

median_uski = statistics.median(uski)
median_siroki = statistics.median(siroki)

# Mod u Pythonu ne postoji u Numpy-ju kao u R-u, pa ćemo koristiti svoju funkciju za računanje moda.
def mod(niz):
    brojac = {}
    for value in niz:
        if value in brojac:
            brojac[value] += 1
        else:
            brojac[value] = 1

    max_frekvencija = max(brojac.values())
    moda = [value for value, frekvencija in brojac.items() if frekvencija == max_frekvencija]

    return mod

mod_uski = mod(uski)
mod_siroki = mod(siroki)

print(f"Srednja vrijednost uskog niza: {mean_uski}")
print(f"Srednja vrijednost širokog niza: {mean_siroki}")

print(f"Medijan uskog niza: {median_uski}")
print(f"Medijan širokog niza: {median_siroki}")

print(f"Mod uskog niza: {mod_uski}")
print(f"Mod širokog niza: {mod_siroki}")

# R
Razmatramo različite mjere koje nam pomažu da razumijemo raznolikost i središnje tendencije podataka. Jedna od tih mjera je raspon (range), koji se definira kao razlika između maksimalne i minimalne vrijednosti u nizu podataka. Druga važna mjera je varijanca (variance), koja mjeri koliko su pojedine vrijednosti u nizu razdvojene od srednje vrijednosti. Pomoću varijance možemo bolje razumjeti raspršenost podataka.

Raspon se računa kao:

range = max(x_1, x_2, ..., x_n) - min(x_1, x_2, ..., x_n)

Za primjer, izračunat ćemo raspon i varijancu za dva različita niza podataka: "uski" i "siroki".
uski <- c(8, 9, 9, 10, 10, 10, 10, 11, 11, 12)
siroki <- c(1, 2, 5, 8, 10, 10, 12, 15, 18, 19)

# Računanje raspona
range_uski <- max(uski) - min(uski)
range_siroki <- max(siroki) - min(siroki)

# Računanje varijance
variance_uski <- var(uski)
variance_siroki <- var(siroki)

range_uski
range_siroki

variance_uski
variance_siroki

Rezultat je:

Za "uski" niz: Raspon = 4, Varijanca = 1.333333
Za "siroki" niz: Raspon = 18, Varijanca = 38.66667

# Python
Razmotrimo različite mjere koje pomažu razumjeti raznolikost i središnje tendencije podataka. Jedna od tih mjera je raspon (range), koji se definira kao razlika između maksimalne i minimalne vrijednosti u nizu podataka. Druga važna mjera je varijanca (variance), koja mjeri koliko su pojedine vrijednosti u nizu razdvojene od srednje vrijednosti. Pomoću varijance možemo bolje razumjeti raspršenost podataka.

Raspon se računa kao: range = max(x_1, x_2, ..., x_n) - min(x_1, x_2, ..., x_n)
import numpy as np

uski = np.array([8, 9, 9, 10, 10, 10, 10, 11, 11, 12])
siroki = np.array([1, 2, 5, 8, 10, 10, 12, 15, 18, 19])

# Računanje raspona
range_uski = np.max(uski) - np.min(uski)
range_siroki = np.max(siroki) - np.min(siroki)

# Računanje varijance
variance_uski = np.var(uski, ddof=1)  # ddof=1 za nepristranu varijancu
variance_siroki = np.var(siroki, ddof=1)

print("Za uski niz: Raspon =", range_uski, ", Varijanca =", variance_uski)
print("Za siroki niz: Raspon =", range_siroki, ", Varijanca =", variance_siroki)

# R varijanca
Iako se standardna devijacija može izračunati i iz varijance (uzimanjem korijena), R ima svoju ugrađenu funkciju `sd()` koja izračunava standardnu devijaciju. Nizovi podataka o kojima je riječ u ovom odlomku imaju sljedeće standardne devijacije:

- `sd(uski)[1]` = 1.154701
- `sd(siroki)[1]` = 6.218253

# Python varijanca
import numpy as np

# Nizovi podataka
uski = [1, 2, 3, 4, 5]
siroki = [10, 20, 30, 40, 50]

# Izračun standardne devijacije
sd_uski = np.std(uski)
sd_siroki = np.std(siroki)

# Ispis rezultata
print(f"Standardna devijacija za uski niz: {sd_uski}")
print(f"Standardna devijacija za siroki niz: {sd_siroki}")

# NADALJE NEMA PROGRAMSKIH KODOVA SVE DO NASLOVA 2.5
