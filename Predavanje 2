# Prije djela 2.1.2 nema programskih kodova
## NAPOMENA:U PYTHONU UNUTAR LISTI kvant UNOSIMO SVOJE VLASTITE PODATKE
# R
Pogledajmo kako bismo u R-u napravili iste tablice i prikazali podatke grafički. Prvo ćemo prevesti tablicu s originalno dobivenim podacima u R data frame, kojeg ćemo nazvati "krgrupa".

Spol <- c("Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž")
Krvna_grupa <- c("A", "0", "B", "0", "0", "A", "AB", "0", "A", "A")
krgrupa <- data.frame(Spol, Krvna_grupa)

Nakon stvaranja data frame-a, tablica "krgrupa" izgleda ovako: 
   Spol Krvna_grupa
1     Ž           A
2     M           0
3     M           B
4     Ž           0
5     Ž           0
6     M           A
7     M          AB
8     Ž           0
9     M           A
10    Ž           A

Sada možemo analizirati podatke. Prvo ćemo upotrijebiti funkciju "table()" kako bismo izradili tablicu koja prikazuje broj pojavnosti svake vrijednosti u jednom od varijabli. 
Na primjer, ako želimo saznati koliko puta se pojavljuju "M" i "Ž" u varijabli "Spol":

table(krgrupa$Spol)

Isto tako, možemo koristiti funkciju "table()" kako bismo izradili tablicu koja prikazuje broj pojavnosti svake krvne grupe u varijabli "Krvna_grupa":

table(krgrupa$Krvna_grupa)

Rezultat će biti:
 0  A AB  B 
 4  4  1  1 

# Python
U Pythonu možemo koristiti Pandas

import pandas as pd

data = {
    'Spol': ["Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž"],
    'Krvna_grupa': ["A", "0", "B", "0", "0", "A", "AB", "0", "A", "A"]
}

krgrupa = pd.DataFrame(data)
print(krgrupa)

# R
Uočili smo da smo izostavili prvi stupac u gornjoj tablici. Koristit ćemo proširenu funkciju "table()" kako bismo dobili broj pojavljivanja svake vrijednosti u pojedinim varijablama.
Također, koristit ćemo "table(krgrupa$Spol)" kako bismo dobili broj muškaraca i žena u našem uzorku te razmotrili odnos frekvencija pojavljivanja vrijednosti "M" i "Ž".

 table(krgrupa$Spol)                                                                                                                                                         
           M              Ž                                                                                                                                                                                   
           5                5

# Python
U Pythonu možemo koristiti Pandas za ostvarivanje istih funkcionalnosti
import pandas as pd

data = {
    'Spol': ["Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž"],
    'Krvna_grupa': ["A", "0", "B", "0", "0", "A", "AB", "0", "A", "A"]
}

krgrupa = pd.DataFrame(data)

# Koristimo value_counts() za izračun frekvencije pojavljivanja svake vrijednosti u stupcu 'Spol'
spol_counts = krgrupa['Spol'].value_counts()

print(spol_counts)

Ovaj Python kod koristi funkciju value_counts() za izračun frekvencije pojavljivanja svake vrijednosti u stupcu 'Spol' u DataFrame-u "krgrupa". Nakon izvođenja koda, dobit ćete rezultat koji prikazuje frekvenciju pojave "M" i "Ž".

# R
Na sljedeći način možemo prikazati frekvenciju pojavljivanja pojedinih krvnih grupa među osobama za koje su dostavljeni podaci:

table(krgrupa$Krvna_grupa)

Rezultat će biti:
  0   A  AB   B 
  4   4   1   1

Kako su nam podaci spremljeni u dataframeove možemo dobiti i zajednički tablični pregled danih podataka po spolu i krvnoj grupi

table(krgrupa)Krvna_grupaSpol 

          Krvna_grupa
Spol       0  A  AB  B
   M       1  2   1  1
   Ž       3  2   0  0

# Python
U Pythonu možemo dobiti ekvivalent koristeći pandas
import pandas as pd

data = {
    'Spol': ["Ž", "M", "M", "Ž", "Ž", "M", "M", "Ž", "M", "Ž"],
    'Krvna_grupa': ["A", "0", "B", "0", "0", "A", "AB", "0", "A", "A"]
}

krgrupa = pd.DataFrame(data)

# Tablični pregled po krvnoj grupi
krvna_grupa_table = pd.crosstab(krgrupa['Krvna_grupa'], krgrupa['Spol'])

print(krvna_grupa_table)

Spol       M  Ž
Krvna_grupa      
0           1  3
A           2  2
AB          1  0
B           1  0

# R
Tablice relativnih frekvencija za krvne grupe dobivamo tako da frekvenciju pojedinih krvnih grupa dijelimo s ukupnim brojem dostupnih podataka. Možemo definirati novu varijablu "relk" kako slijedi:

relk <- krgrupa$Krvna_grupa / nrow(krgrupa)

Onda možemo primijeniti funkciju "table" kako bismo dobili tablicu relativnih frekvencija, no možemo i jednostavnije:

table(krgrupa$Krvna_grupa) / nrow(krgrupa)

Rezultat će izgledati ovako:
   0      A   AB    B 
  0.4    0.4  0.1   0.1

# Python
Tablice relativnih frekvencija za krvne grupe dobivamo tako da frekvenciju pojedinih krvnih grupa dijelimo s ukupnim brojem dostupnih podataka. Koristit ćemo biblioteku Pandas
import pandas as pd

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Izračun relativnih frekvencija za krvne grupe
relk = krgrupa['Krvna_grupa'].value_counts() / len(krgrupa)

print(relk)

Ovaj Python kod koristi funkciju value_counts() i dijeli rezultate s ukupnim brojem dostupnih podataka kako bi dobio relativne frekvencije krvnih grupa.

0      0.4
A      0.4
AB     0.1
B      0.1
Name: Krvna_grupa, dtype: float64

# R
U nekim situacijama, koristimo svojstvo R-a da možemo vršiti operacije nad jedinstvenim elementima objekta, a to je korisno kada radimo s tablicama. 
U ovom slučaju, uočavamo da R u svojoj osnovnoj verziji ispisuje tablice horizontalno. Međutim, ponekad je preglednije ispisati tablice vertikalno. Kako bi olakšali ovaj zadatak i poboljšali prikaz tablica, možemo koristiti paket "plyr".

library("plyr")
count(krgrupa, "Krvna_grupa")

Ovaj kod koristi "plyr" paket kako bi ispisao tablicu vertikalno, prikazujući frekvenciju svake krvne grupe. Rezultat će izgledati ovako:

  Krvna_grupa freq
1           0    4
2           A    4
3          AB    1
4           B    1

Ovako ćemo dobiti pregledniji prikaz frekvencija krvnih grupa u tablici "krgrupa".

# Python
U  Pythonu se ponovno koristi Pandas
import pandas as pd

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Koristimo funkciju value_counts() za dobivanje frekvencije svake krvne grupe
frekvencije = krgrupa['Krvna_grupa'].value_counts().reset_index()
frekvencije.columns = ['Krvna_grupa', 'freq']

print(frekvencije)

Ovaj Python kod koristi value_counts() da dobije frekvenciju svake krvne grupe i zatim koristi reset_index() i columns kako bi formatirao tablicu. 
Nakon izvođenja koda, dobit ćete ekvivalentan pregled frekvencija krvnih grupa kao što ste imali u R-u:

  Krvna_grupa  freq
0           0     4
1           A     4
2          AB     1
3           B     1

# R
S obzirom na to da postoji drugi paket, poput Display, koji omogućava dodatno prilagođavanje tabličnog prikaza, možemo koristiti njegove funkcionalnosti kako bismo bolje prilagodili prikaz tablica.
Nakon toga, korištenjem osnovne R funkcije barplot(), možemo vizualizirati tablicu frekvencija krvnih grupa. 
Na taj način, tablicu frekvencija krvnih grupa možemo prikazati jednostavnom grafikonom, kao što je prikazano na donjoj slici. 
Kao i kod drugih funkcija za grafički prikaz podataka, možemo prilagoditi parametre slike kako bismo kontrolirali izgled grafikona. U slučaju prikaza frekvencija krvnih grupa, možemo smanjiti veličinu fonta ili promijeniti naziv grafa na "Stupčasti prikaz frekvencija krvnih grupa".

par(mar=c(2,2,2,1))
barplot(table(krgrupa$Krvna_grupa),
        main="Stupčasti prikaz frekvencije krvnih grupa",
        cex.axis=0.7,
        cex.names=0.7,
        cex.main=0.7)

# Python
U Pythonu ćemo koristiti Pandas i Matplotlib za grafički prikaz podataka:
import pandas as pd
import matplotlib.pyplot as plt

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Kreiranje grafikona stupčaste frekvencije
plt.figure(figsize=(6, 4))  # Postavljanje veličine grafikona
plt.bar(krgrupa['Krvna_grupa'].value_counts().index, krgrupa['Krvna_grupa'].value_counts(), color='skyblue')
plt.title("Stupčasti prikaz frekvencije krvnih grupa")  # Naslov grafikona
plt.xlabel("Krvna grupa")  # X-osa
plt.ylabel("Broj osoba")  # Y-osa
plt.xticks(rotation=0)  # Rotacija oznaka na X-osi
plt.tight_layout()

plt.show()  # Prikaz grafikona


# R
S vremena na vrijeme, osim tablice relativnih frekvencija, prikazivanje tablice kumulativnih relativnih frekvencija može biti relevantno. Tablicu kumulativnih relativnih frekvencija možemo jednostavno stvoriti koristeći jednu od osnovnih R-ovih funkcija, cumsum, koja izračunava kumulativni zbroj danog niza elemenata. Da ne bude zabune, ako imamo brojeve 1, 3 i 5, onda je kumulativni zbroj prvih dva broja 4, dok je kumulativni zbroj svih tri broja 9.

Primjer tablice kumulativnih relativnih frekvencija za krvne grupe (prema prethodnim podacima) je naveden u nastavku:

cumsum(table(krgrupa$Krvna_grupa) / nrow(krgrupa))

Ova tablica govori da 40% ispitanika ima krvnu grupu 0, 80% ispitanika ima krvnu grupu 0 ili A, te 90% ispitanika ima barem jednu od krvnih grupa 0, A ili B.
0          A          AB             B
0.4           0.8           0.9           1.0

# Python
Python kod pandas za izračun kumulativnih relativnih frekvencija i stvara DataFrame s kumulativnim frekvencijama. Nakon izvođenja koda, dobit ćemo ekvivalentnu tablicu kumulativnih relativnih frekvencija kao što smo imali u R-u
import pandas as pd

data = {
    'Krvna_grupa': ["0", "A", "AB", "B"],
}

krgrupa = pd.DataFrame(data)

# Izračun kumulativnih relativnih frekvencija
relative_frequencies = krgrupa['Krvna_grupa'].value_counts(normalize=True).sort_index()
cumulative_frequencies = relative_frequencies.cumsum()

# Dodajte kumulativne relativne frekvencije u novi stupac 'Cumulative_Freq'
cumulative_frequencies_df = pd.DataFrame(cumulative_frequencies, columns=['Cumulative_Freq'])

print(cumulative_frequencies_df)

  Cumulative_Freq
0              0.4
A              0.8
AB             0.9
B              1.0

# R
Pogledajmo podatke o visini, težini i indeksu tjelesne težine koje smo vidjeli na kraju prošlog poglavlja. Učitat ćemo ih korištenjem funkcije 
read.xlsx i spremiti u varijablu kvant
# Učitavanje potrebnih biblioteka
library("rJava")
library("xlsx")
library("xlsxjars")

# Učitavanje kvantitativnih podataka iz Excel datoteke
kvant <- read.xlsx("BMI2.xlsx", sheetName = "Druga", header = TRUE, endRow = 13)

# Uklanjanje prvog stupca (Ime) jer nije potreban
kvant <- kvant[, c(2, 3, 4, 5)]

# Provjera tipova preostalih podataka
str(kvant)

Podsjetimo se o kojim je podacima riječ
> kvant
Ovdje su primjeri podataka iz kvantitativnih podataka:

NA|   Ime  |  Težina |  Visina |   BMI   |
  |--------|---------|---------|----------|
  |   A    |    60   |   165   | 22.038572|
  |   B    |    80   |   180   | 24.69136 |
  |   C    |    85   |   175   | 27.755104|
  |   D    |    84   |   184   | 24.810965|
  |   E    |    62   |   168   | 21.967126|
  |   F    |    65   |   175   | 21.224497|
  |   G    |    86   |   184   | 25.401708|
  |   H    |    86   |   192   | 23.328999|
  |   I    |    95   |   182   | 28.68011 |
  |   J    |    78   |   178   | 24.61810 |
  |   K    |    70   |   175   | 22.85714 |
  |   L    |    68   |   170   | 23.52941 |
Vidimo da je prva kolona zapravo višak, a pritom je i bez imena. Možemo je izbrisati tako da varijabli kvant pridružimo sve vrijednosti osim onih iz prve kolone:

kvant<-kvant[,c(2,3,4,5)]
Provjerimo kojeg su tipa preostali podaci: str(kvat)

'data.frame': 12 obs. of 4 variables:
 $ Ime  : chr  "A" "B" "C" "D" ...
 $ Težina: num  60 80 85 84 62 65 86 86 95 78 ...
 $ Visina: num  165 180 175 184 168 175 184 192 182 178 ...
 $ BMI  : num  22 24.7 27.8 24.8 22 ...

Kao i u slučaju kvalitativnih podataka, lako možemo napraviti tablice frekvencija za kvantitativne podatke, na primjer, pojavljivanje različitih visina među osobama čije smo podatke dobili:

table(kvant$Visina)

Rezultat će izgledati ovako:
165 168 170 175 178 180 182 184 192 
1   1   1     3   1   1   1   2   1 

Naravno, jasno je da se visina 175 javlja najčešće, ali u ovom slučaju to nije toliko zanimljivo. Kada se radi s kvantitativnim podacima, imamo mnogo više informacija koje možemo koristiti prilikom analize podataka. Prije svega, to uključuje mjeru središnje tendencije i mjeru raspršenosti podataka.

Vratit ćemo se BMI podacima kako bismo definirali navedene pojmove.

# PYTHON
U Pythonu se ekvivalentni kod može napraviti korsiteći Pandas:
import pandas as pd

# Učitavanje kvantitativnih podataka iz Excel datoteke
kvant = pd.read_excel("BMI2.xlsx", sheet_name="Druga", header=0, nrows=13)

# Izbacivanje prvog stupca (Ime) jer nije potreban
kvant = kvant.iloc[:, 1:]

# Ispis tipova preostalih podataka
print(kvant.dtypes)

# Prikaz tablice frekvencija visine
visina_counts = kvant['Visina'].value_counts()
print(visina_counts)

# DIO 2.2 NE SADRŽI NIKAKVE PROGRAMSKE DJELOVE
# 2.2.1
# R
Aritmetička sredina, mod i medijan
# R
U sljedećem primjeru imamo implementiranu R funkciju mean() koja računa aritmetičku sredinu:
x <- c(24, 5, 9, 12, 22, 2, 89, 4, 13)
mean(x)[1]  # 20

Kao što je dobro poznato, aritmetička sredina računa srednju vrijednost dostupnih vrijednosti iz niza podataka, a ova mjera pomaže u eliminaciji izvanrednih i ekstremnih vrijednosti (outliers). 
U ovom konkretnom primjeru, ukoliko uklonimo vrijednost 89 iz niza podataka, aritmetička sredina se smanjuje na 11.375, što se može postići sljedećim koracima:

x <- x[!x == 89]
mean(x)[1]  # 11.375

# PYTHON
U Pythonu koristimo ugrađenu funkciju mean iz NumPy-a
import numpy as np

x = np.array([24, 5, 9, 12, 22, 2, 89, 4, 13])
result = np.mean(x)
print(result)  # Output: 20.0

# Uklanjanje vrijednosti 89 i ponovno računanje aritmetičke sredine
x = x[x != 89]

result = np.mean(x)
print(result)  # Output: 11.375

# R medijan
Medijan je statistička mjera središnje tendencije koja predstavlja srednju vrijednost unutar poretka podataka.
U R-u, medijan se može izračunati pomoću funkcije median(). Evo primjera i objašnjenja kako se koristi medijan:

# Primjer izračunavanja medijana
# Prvo, koristimo ugrađenu funkciju median() za izračun medijana za cijeli niz podataka
median(c(24, 5, 9, 12, 22, 2, 89, 4, 13))[1]  # Output: 12

# Ako uklonimo vrijednost 89 iz niza 'x' i ponovno izračunamo medijan, dobivamo:
median(x)[1]  # Output: 10.5

U ovom primjeru, medijan originalnog niza (24, 5, 9, 12, 22, 2, 89, 4, 13) iznosi 12. Nakon što izbacimo vrijednost 89 i ponovno izračunamo medijan, dobivamo medijan vrijednosti 10.5.

Medijan je koristan za mjerenje središnje tendencije, a posebno je koristan kada imate outliers (ekstremne vrijednosti) u vašim podacima, jer neće biti toliko osjetljiv na te ekstremne vrijednosti kao aritmetička sredina. 
Medijan je vrijednost koja dijeli vaše podatke na dvije jednake polovice, tako da je polovina vaših podataka manja od medijana, a polovina veća.

# Python medijan
U Pythonu koristimo funkciju median() iz biblioteke NumPy za izračun medijana. Prvo, izračunavamo medijan za originalni niz podataka, a zatim izračunavamo medijan za niz x nakon što smo iz njega izbacili vrijednost 89.

import numpy as np

# Primjer izračunavanja medijana
# Prvo, koristimo funkciju median() iz biblioteke NumPy za izračun medijana za cijeli niz podataka
data = [24, 5, 9, 12, 22, 2, 89, 4, 13]
median_value = np.median(data)
print(median_value)  # Output: 12.0

# Ako uklonimo vrijednost 89 iz niza 'x' i ponovno izračunamo medijan, dobivamo:
x = [value for value in x if value != 89]
median_x = np.median(x)
print(median_x)  # Output: 10.5

#R mod
Mod je statistička mjera koja predstavlja vrijednost koja se najčešće pojavljuje u nizu brojeva. Da bismo izračunali mod niza brojeva u R-u, koristimo funkciju table() za stvaranje tablice frekvencija svakog broja u nizu, a zatim koristimo funkciju names() kako bismo dobili vrijednosti koje imaju najveću frekvenciju. No, primijetimo da su vrijednosti koje vraća names() u obliku znakova (character), pa ih trebamo pretvoriti u numerički format kako bismo dobili mod. Slijedi R kod koji to obavlja:
# Stvaranje uzorka brojeva
nuz <- c(1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9)

# Izračunavanje moda niza brojeva
mod_values <- as.numeric(names(table(nuz))[table(nuz) == max(table(nuz))])
print(mod_values)

# Python mod
U Pythonu mod možemo izračunati pomoću biblioteke statistics:

import statistics

# Stvaranje uzorka brojeva
nuz = [1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9]

# Izračunavanje moda niza brojeva
mod_values = statistics.multimode(nuz)
print(mod_values)

Ovaj kod koristi funkciju multimode() iz statistics biblioteke kako bi pronašao sve vrijednosti koje se pojavljuju najčešće u nizu. Rezultat će sadržavati sve takve mod vrijednosti koje se pojavljuju u nizu nuz

Postoji alternativni način, pomoću numpyja:

import numpy as np

# Stvaranje uzorka brojeva
nuz = np.array([1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9])

# Pronalazak mod vrijednosti
unique_values, counts = np.unique(nuz, return_counts=True)
max_count = np.max(counts)
mod_values = unique_values[counts == max_count]
print(mod_values)

# R
U R-u se mogu definirati vlastite korisnički definirane funkcije. U donjem primjeru, definirana je jednostavna funkcija Mod(), koja ima jedan argument i računa mod numeričkog vektora:
Mod <- function(x) {
  as.numeric(names(table(x))[table(x) == max(table(x))])
}

Ova funkcija uzima vektor x kao ulazni argument. Prvo koristi funkciju table(x) kako bi izračunala frekvenciju pojavljivanja svake vrijednosti u vektoru. Zatim koristi names() kako bi dobila imena (vrijednosti) koje imaju maksimalnu frekvenciju. Konačno, pretvara rezultat u numerički format pomoću as.numeric().

Primjer korištenja funkcije:

nuz <- c(1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9)
mod_result <- Mod(nuz)
print(mod_result)

# Python
U Pythonu, također možemo korisnički definirati funkciju za mod. To možemo napraviti na slijedeći način: 
import numpy as np

def mod(x):
    unique, counts = np.unique(x, return_counts=True)
    max_count = np.max(counts)
    mode_values = unique[counts == max_count]
    return mode_values

nuz = np.array([1, 2, 3, 3, 4, 5, 6, 6, 7, 8, 8, 9])
mod_result = mod(nuz)
print(mod_result)

# R
Razmatramo pojmove središnje tendencije i raspršenosti podataka u statistici. Središnja tendencija je mjera koja opisuje centralnu ili tipičnu vrijednost u skupu podataka, dok je raspršenost mjera koja opisuje varijaciju podataka i koliko su raznolike vrijednosti.

Razmotrimo primjer s nizovima podataka:

Prvi niz podataka: 8, 9, 9, 10, 10, 10, 10, 11, 11, 12
Drugi niz podataka: 1, 2, 5, 8, 10, 10, 12, 15, 18, 19

Prvi niz podataka je prilično koncentriran oko vrijednosti 10, što ukazuje na malu raspršenost podataka. Drugi niz podataka je znatno raznolikiji, što znači da ima veću raspršenost.

Unatoč razlici u raspršenosti, i aritmetička sredina i medijan oba niza podataka su 10. To nas podsjeća da iako te mjere pružaju informacije o središnjoj tendenciji, ne govore nam ništa o raspršenosti podataka. Da bismo bolje razumjeli podatke, trebamo razmotriti i druge statističke mjere koje opisuju raspršenost, kao što su varijanca i standardna devijacija.

uski <- c(8, 9, 9, 10, 10, 10, 10, 11, 11, 12)
siroki <- c(1, 2, 5, 8, 10, 10, 12, 15, 18, 19)

mean(uski) # 10
mean(siroki) # 10

median(uski) # 10
median(siroki) # 10

Mod(uski) # 10
Mod(siroki) # 10

# PYTHON
import statistics

uski = [8, 9, 9, 10, 10, 10, 10, 11, 11, 12]
siroki = [1, 2, 5, 8, 10, 10, 12, 15, 18, 19]

mean_uski = statistics.mean(uski)
mean_siroki = statistics.mean(siroki)

median_uski = statistics.median(uski)
median_siroki = statistics.median(siroki)

# Mod u Pythonu ne postoji u Numpy-ju kao u R-u, pa ćemo koristiti svoju funkciju za računanje moda.
def mod(niz):
    brojac = {}
    for value in niz:
        if value in brojac:
            brojac[value] += 1
        else:
            brojac[value] = 1

    max_frekvencija = max(brojac.values())
    moda = [value for value, frekvencija in brojac.items() if frekvencija == max_frekvencija]

    return mod

mod_uski = mod(uski)
mod_siroki = mod(siroki)

print(f"Srednja vrijednost uskog niza: {mean_uski}")
print(f"Srednja vrijednost širokog niza: {mean_siroki}")

print(f"Medijan uskog niza: {median_uski}")
print(f"Medijan širokog niza: {median_siroki}")

print(f"Mod uskog niza: {mod_uski}")
print(f"Mod širokog niza: {mod_siroki}")

# R
Razmatramo različite mjere koje nam pomažu da razumijemo raznolikost i središnje tendencije podataka. Jedna od tih mjera je raspon (range), koji se definira kao razlika između maksimalne i minimalne vrijednosti u nizu podataka. Druga važna mjera je varijanca (variance), koja mjeri koliko su pojedine vrijednosti u nizu razdvojene od srednje vrijednosti. Pomoću varijance možemo bolje razumjeti raspršenost podataka.

Raspon se računa kao:

range = max(x_1, x_2, ..., x_n) - min(x_1, x_2, ..., x_n)

Za primjer, izračunat ćemo raspon i varijancu za dva različita niza podataka: "uski" i "siroki".
uski <- c(8, 9, 9, 10, 10, 10, 10, 11, 11, 12)
siroki <- c(1, 2, 5, 8, 10, 10, 12, 15, 18, 19)

# Računanje raspona
range_uski <- max(uski) - min(uski)
range_siroki <- max(siroki) - min(siroki)

# Računanje varijance
variance_uski <- var(uski)
variance_siroki <- var(siroki)

range_uski
range_siroki

variance_uski
variance_siroki

Rezultat je:

Za "uski" niz: Raspon = 4, Varijanca = 1.333333
Za "siroki" niz: Raspon = 18, Varijanca = 38.66667

# Python
Razmotrimo različite mjere koje pomažu razumjeti raznolikost i središnje tendencije podataka. Jedna od tih mjera je raspon (range), koji se definira kao razlika između maksimalne i minimalne vrijednosti u nizu podataka. Druga važna mjera je varijanca (variance), koja mjeri koliko su pojedine vrijednosti u nizu razdvojene od srednje vrijednosti. Pomoću varijance možemo bolje razumjeti raspršenost podataka.

Raspon se računa kao: range = max(x_1, x_2, ..., x_n) - min(x_1, x_2, ..., x_n)
import numpy as np

uski = np.array([8, 9, 9, 10, 10, 10, 10, 11, 11, 12])
siroki = np.array([1, 2, 5, 8, 10, 10, 12, 15, 18, 19])

# Računanje raspona
range_uski = np.max(uski) - np.min(uski)
range_siroki = np.max(siroki) - np.min(siroki)

# Računanje varijance
variance_uski = np.var(uski, ddof=1)  # ddof=1 za nepristranu varijancu
variance_siroki = np.var(siroki, ddof=1)

print("Za uski niz: Raspon =", range_uski, ", Varijanca =", variance_uski)
print("Za siroki niz: Raspon =", range_siroki, ", Varijanca =", variance_siroki)

# R varijanca
Iako se standardna devijacija može izračunati i iz varijance (uzimanjem korijena), R ima svoju ugrađenu funkciju `sd()` koja izračunava standardnu devijaciju. Nizovi podataka o kojima je riječ u ovom odlomku imaju sljedeće standardne devijacije:

- `sd(uski)[1]` = 1.154701
- `sd(siroki)[1]` = 6.218253

# Python varijanca
import numpy as np

# Nizovi podataka
uski = [1, 2, 3, 4, 5]
siroki = [10, 20, 30, 40, 50]

# Izračun standardne devijacije
sd_uski = np.std(uski)
sd_siroki = np.std(siroki)

# Ispis rezultata
print(f"Standardna devijacija za uski niz: {sd_uski}")
print(f"Standardna devijacija za siroki niz: {sd_siroki}")

# NADALJE NEMA PROGRAMSKIH KODOVA SVE DO NASLOVA 2.5

# R
Vratimo se sada na primjer s indeksom tjelesne mase (BMI). Podaci su spremljeni u dataframe "kvant", a imena stupaca (vektora) u dataframe-u su Ime, Težina, Visina i BMI. Opremljeni novim znanjem, sada ćemo lako izračunati neke osnovne kvantitativne mjere tih podataka.

- Srednja vrijednost težine: `mean(kvant$Tezina)` = 76.58333
- Medijan težine: `median(kvant$Tezina)` = 79
- Standardna devijacija težine: `sd(kvant$Tezina)` = 11.26102
- Raspon težine: `range(kvant$Tezina)` = 60 do 95

Primijetite da R-ova funkcija `range()` vraća minimalnu i maksimalnu vrijednost promatranih podataka. Naravno, raspon podataka, u prirodnom smislu, jednak je razlici između ta dva broja, odnosno 35.

# Python
import numpy as np
import pandas as pd

# Podaci
data = {
    'Ime': ['Osoba1', 'Osoba2', 'Osoba3', 'Osoba4', 'Osoba5'],
    'Tezina': [70, 80, 75, 95, 60],
    'Visina': [1.75, 1.80, 1.70, 1.90, 1.65],
    'BMI': [22.86, 24.69, 25.95, 26.32, 22.04]
}

# Pretvaranje podataka u DataFrame
df = pd.DataFrame(data)

# Izračun kvantitativnih mjera
srednja_vrijednost_tezine = np.mean(df['Tezina'])
medijan_tezine = np.median(df['Tezina'])
standardna_devijacija_tezine = np.std(df['Tezina'])
raspon_tezine = np.ptp(df['Tezina'])

# Ispis rezultata
print(f"Srednja vrijednost težine: {srednja_vrijednost_tezine:.5f}")
print(f"Medijan težine: {medijan_tezine:.5f}")
print(f"Standardna devijacija težine: {standardna_devijacija_tezine:.5f}")
print(f"Raspon težine: {raspon_tezine}")

# R
# Prikaz osnovnih statistika za stupac "Težina"
summary(kvant$Tezina)
# Rezultat:
#     Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
#    60.00    67.25    79.00    76.58    85.25    95.00

# Prikaz osnovnih statistika za cijeli DataFrame "kvant"
summary(kvant)
# Rezultat:
#      Ime                Tezina           Visina            BMI        
#  Length:12          Min.   :60.00   Min.   :165.0   Min.   :21.22  
#  Class :character   1st Qu.:67.25   1st Qu.:173.8   1st Qu.:22.65  
#  Mode  :character   Median :79.00   Median :176.5   Median :24.07  
#                     Mean   :76.58   Mean   :177.3   Mean   :24.24  
#                     3rd Qu.:85.25   3rd Qu.:182.5   3rd Qu.:24.96  
#                     Max.   :95.00   Max.   :192.0   Max.   :28.6

# Python
U Pythonu koristimo .describe()
import pandas as pd

# Podaci
data = {
    'Ime': ['Osoba1', 'Osoba2', 'Osoba3', 'Osoba4', 'Osoba5'],
    'Tezina': [60.00, 67.25, 79.00, 76.58, 95.00],
    'Visina': [165.0, 173.8, 176.5, 177.3, 192.0],
    'BMI': [21.22, 22.65, 24.07, 24.24, 28.6]
}

# Pretvaranje podataka u DataFrame
df = pd.DataFrame(data)

# Prikaz osnovnih statistika za stupac "Tezina"
print(df['Tezina'].describe())

# Prikaz osnovnih statistika za cijeli DataFrame "kvant"
print(df.describe())

# R
# Postavljanje margina za graf
par(mar = c(4, 4, 2, 1))

# Priprema za prikaz podataka o težini
barplot(
  kvant$Tezina,
  names.arg = kvant$Ime,
  ylim = c(0, 100),
  main = "Podaci o težini",
  xlab = "Osobe",
  ylab = "Težina (kg)",
  cex.axis = 0.6,
  cex.names = 0.5,
  cex.main = 0.9
)

Ovdje je prikazan bar grafikon koji prikazuje podatke o težini različitih osoba. Imena osoba su prikazana na x-osi, a težina (u kg) na y-osi. Grafikon prikazuje raspodjelu težina među osobama.

# Python
import matplotlib.pyplot as plt

# Podaci o težini i imenima osoba
tezina = [60, 67.25, 79, 76.58, 85.25, 95]
ime = ["Osoba1", "Osoba2", "Osoba3", "Osoba4", "Osoba5", "Osoba6"]

# Postavljanje margina za graf
plt.subplots_adjust(bottom=0.15, left=0.15)

# Priprema za prikaz podataka o težini
plt.bar(ime, tezina)
plt.ylim(0, 100)
plt.title("Podaci o težini")
plt.xlabel("Osobe")
plt.ylabel("Težina (kg)")
plt.xticks(rotation=45, ha="right", fontsize=8)
plt.yticks(fontsize=8)
plt.title("Podaci o težini", fontsize=12)

# Tekstualni opis
plt.text(0.5, -0.25, "Ovdje je prikazan bar grafikon koji prikazuje podatke o težini različitih osoba.", transform=plt.gca().transAxes)
plt.text(0.5, -0.3, "Imena osoba su prikazana na x-osi, a težina (u kg) na y-osi.", transform=plt.gca().transAxes)
plt.text(0.5, -0.35, "Grafikon prikazuje raspodjelu težina među osobama.", transform=plt.gca().transAxes)

# Prikaz grafa
plt.show()

# R

par(mar = c(2, 2, 2, 1))

# Priprema za prikaz podataka o težini
barplot(
  kvant$Tezina,
  names.arg = kvant$Ime,
  xlim = c(0, 100),
  main = "Podaci o težini",
  horiz = TRUE,
  col = "darkred",
  cex.axis = 0.7,
  cex.names = 0.7,
  cex.main = 0.9,
  las = 1
)

Ovdje je prikazan horizontalni bar grafikon koji prikazuje podatke o težini različitih osoba.Imena osoba su prikazana na y-osi, a težina (u kg) na x-osi. Grafikon prikazuje raspodjelu težina među osobama.

# Python
import matplotlib.pyplot as plt

# Podaci
ime = kvant['Ime']
tezina = kvant['Tezina']

# Postavljanje margina za graf
plt.subplots_adjust(left=0.2, right=0.9, top=0.9, bottom=0.2)

# Priprema za prikaz podataka o težini
plt.barh(ime, tezina, color='darkred')

# Postavljanje osi i naslova
plt.xlim(0, 100)
plt.xlabel('Težina (kg)')
plt.title('Podaci o težini')

# Prikaz grafikona
plt.show()

# Tekstualni opis
print("Ovdje je prikazan horizontalni bar grafikon koji prikazuje podatke o težini različitih osoba.")
print("Imena osoba su prikazana na y-osi, a težina (u kg) na x-osi.")
print("Grafikon prikazuje raspodjelu težina među osobama.")

# R
U nastavku se koristi funkcija hist() za stvaranje histograma koji prikazuje raspodjelu visina iz podataka "kvant". U kodu je također postavljeno nekoliko parametara kako bi se pravilno formatirao graf. Margine grafa su prilagođene s par(mar = c(2, 2, 2, 1)) kako bi graf bio čitljiv.

Histogram je grafički način prikazivanja distribucije podataka. Na x-osi se nalaze različite vrijednosti visine, dok je na y-osi prikazana frekvencija pojavljivanja svake visine. Histogram omogućava vizualno prepoznavanje učestalosti različitih visina u podacima, što je korisno za analizu distribucije podataka.
# Postavljanje margina za graf
par(mar = c(2, 2, 2, 1))

# Prikaz histograma visine
hist(kvant$Visina)

# Python
import matplotlib.pyplot as plt

# Postavljanje margina za graf
plt.subplots_adjust(left=0.15)
plt.figure(figsize=(6, 4))

# Prikaz histograma visine
plt.hist(kvant['Visina'], bins=10, edgecolor='k', color='blue')
plt.title('Histogram visine')
plt.xlabel('Visina')
plt.ylabel('Broj pojavljivanja')

plt.show()

# R 
Možemo mijenjati razine parametara histograma
par(mar = c(4, 4, 1, 1))
h <- hist(
  kvant$Visina,
  main = "Visina ispitanika",
  xlab = "Visina",
  ylab = "Frekvencija pojavljivanja",
  breaks = length(kvant$Visina),
  cex.axis = 0.7,
  cex.main = 0.8,
  cex.lab = 0.8,
  col = "aquamarine3"
)

# Python
import matplotlib.pyplot as plt
import numpy as np

# Podaci
visina = kvant['Visina']  # Ovdje ubacimo naše podatke

# Postavljanje stila grafikona
plt.style.use('ggplot')

# Postavljanje parametara grafikona
plt.figure(figsize=(6, 6))  # Veličina grafikona
plt.hist(visina, bins=len(visina), color='aquamarine', edgecolor='black')
plt.title('Visina ispitanika', fontsize=14)
plt.xlabel('Visina', fontsize=12)
plt.ylabel('Frekvencija pojavljivanja', fontsize=12)

# Prilagodba veličine oznaka na osima
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)

plt.show()

# R
Možemo vidjeti od čega se naš histogram uopće sastoji
h$breaks
# [1] 164 166 168 170 172 174 176 178 180 182 184 186 188 190 192

h$counts
# [1] 1 1 1 0 0 3 1 1 1 2 0 0 0 1

h$density
# [1] 0.04166667 0.04166667 0.04166667 0.00000000 0.00000000 0.12500000 0.04166667 0.04166667 0.04166667 0.08333333 0.00000000 0.00000000 0.00000000 0.04166667

h$mids
# [1] 165 167 169 171 173 175 177 179 181 183 185 187 189 191

h$xname
# [1] "kvant$Visina"

h$equidist
# [1] TRUE

attr(h, "class")
# [1] "histogram"

# Python
Python  koristi numpy.histogram za izračunavanje histograma i pristupa relevantnim podacima poput granica (breaks), brojača (counts), gustine (density), srednjih tačaka (mids), i drugih sličnih podataka.
import numpy as np
import matplotlib.pyplot as plt

# Podaci o visini
visina = kvant['Visina']  # Zamijenite ovo sa stvarnim podacima

# Izračunavanje histograma
hist, bin_edges = np.histogram(visina, bins='auto', density=False)

# Prikazivanje histograma
plt.hist(visina, bins=bin_edges, color='aquamarine', edgecolor='black')
plt.title('Visina ispitanika', fontsize=14)
plt.xlabel('Visina', fontsize=12)
plt.ylabel('Frekvencija pojavljivanja', fontsize=12)

# Pristup izračunatim podacima
print("breaks:", bin_edges)
print("counts:", hist)
print("density:", hist / len(visina))
print("mids:", (bin_edges[1:] + bin_edges[:-1]) / 2)
print("xname:", "visina")
print("equidist:", True)
print("class_attr:", "histogram")

plt.show()

# R
par(mar = c(4, 4, 2, 1))
hist(
  kvant$Visina,
  main = "Visina ispitanika",
  xlab = "Visina",
  ylab = "Relativna frekvencija",
  breaks = length(kvant$Visina),
  cex.axis = 0.75,
  cex.main = 0.85,
  cex.lab = 0.8,
  col = "darkmagenta",
  probability = TRUE
)

# Python
import numpy as np
import matplotlib.pyplot as plt

# Podaci o visini
visina = kvant['Visina']  # Zamijenite ovo sa stvarnim podacima

# Postavljanje stila grafikona
plt.style.use('ggplot')

# Postavljanje parametara grafikona
plt.figure(figsize=(6, 6))  # Veličina grafikona
plt.hist(
    visina,
    bins=len(visina),
    color='darkmagenta',
    edgecolor='black',
    density=True  # Omogućavanje relativne frekvencije
)
plt.title('Visina ispitanika', fontsize=14)
plt.xlabel('Visina', fontsize=12)
plt.ylabel('Relativna frekvencija', fontsize=12)

# Prilagodba veličine oznaka na osama
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)

plt.show()

# R
par(mar = c(4, 4, 2, 1))
hist(
  kvant$Visina,
  main = "Visina ispitanika - različite širine",
  xlab = "Visina",
  ylab = "Relativna frekvencija",
  ylim = c(0, 0.06),
  cex.axis = 0.75,
  cex.main = 0.85,
  cex.lab = 0.8,
  breaks = c(165, 168, 172, 178, 180, 182, 192),
  col = "darkmagenta",
  probability = TRUE
)

# Python
import numpy as np
import matplotlib.pyplot as plt

# Podaci o visini
visina = kvant['Visina']  # Zamijenite ovo sa stvarnim podacima

# Postavljanje stila grafikona
plt.style.use('ggplot')

# Postavljanje parametara grafikona
plt.figure(figsize=(6, 6))  # Veličina grafikona
bin_edges = [165, 168, 172, 178, 180, 182, 192]
plt.hist(
    visina,
    bins=bin_edges,
    color='darkmagenta',
    edgecolor='black',
    density=True  # Omogućavanje relativne frekvencije
)
plt.title('Visina ispitanika - različite širine', fontsize=14)
plt.xlabel('Visina', fontsize=12)
plt.ylabel('Relativna frekvencija', fontsize=12)
plt.ylim(0, 0.06)

# Prilagodba veličine oznaka na osama
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)

plt.show()

# R
Završit ćemo ovaj kratki pregled grafičkog prikaza podataka korištenjem jednog tipa grafa, takozvanog boxplota
(funkcija u R-u je `boxplot()`). Boxplot se na engleskom naziva "box and whiskers diagram", a može se prevesti
i kao "pravokutni dijagram". On nam je koristan u kontekstu analize grupiranja podataka, njihovog rasporeda i identifikacije ekstremnih vrijednosti (outliera).

par(mar = c(2, 2, 2, 1))
boxplot(
  kvant$Visina,
  cex.axis = 0.7,
  cex.main = 0.8,
  main = "Boxplot visine osoba"
)
# Python
import matplotlib.pyplot as plt

# Podaci o visini
visina = kvant['Visina']  # Zamijenite ovo sa stvarnim podacima

# Postavljanje stila grafikona
plt.style.use('ggplot')

# Postavljanje parametara grafikona
plt.figure(figsize=(6, 6))  # Veličina grafikona
plt.boxplot(
    visina,
    vert=False,  # Horizontalni prikaz
    widths=0.6,  # Širina "pravokutnih" dijelova
    patch_artist=True,  # Omogućava stilizaciju "pravokutnih" dijelova
    flierprops=dict(marker='o', markersize=5, markerfacecolor='red', markeredgecolor='red')  # Stilizacija outlier-a
)
plt.title('Boxplot visine osoba', fontsize=14)
plt.xlabel('Visina', fontsize=12)

# Prilagodba veličine oznaka na osama
plt.yticks([])  # Uklanjanje oznaka s y-ose

plt.show()

#R
Horizontalni boxplot
par(mar = c(2, 2, 2, 1))
boxplot(
  kvant$BMI,
  main = "Boxplot indeksa tjelesne mase",
  cex.axis = 0.7,
  cex.main = 0.8,
  horizontal = TRUE
)

# Python
import matplotlib.pyplot as plt

# Podaci o indeksu tjelesne mase (BMI)
bmi = kvant['BMI']  # Zamijenite ovo sa stvarnim podacima

# Postavljanje stila grafikona
plt.style.use('ggplot')

# Postavljanje parametara grafikona
plt.figure(figsize=(6, 3))  # Veličina grafikona (prilagodite prema potrebi)
plt.boxplot(
    bmi,
    vert=False,  # Horizontalni prikaz
    widths=0.6,  # Širina "pravokutnih" dijelova
    patch_artist=True,  # Omogućava stilizaciju "pravokutnih" dijelova
)
plt.title('Boxplot indeksa tjelesne mase', fontsize=14)
plt.xlabel('BMI', fontsize=12)

# Prilagodba veličine oznaka na osama
plt.yticks([])  # Uklanjanje oznaka s y-ose

plt.show()

# R
Na jednom grafu možemo pokazati podatke za sva 3 vektora
# Postavite odgovarajuće margine za grafikon
par(mar = c(2, 2, 2, 1))

# Nacrtajte boxplot za odabrane kolone
boxplot(
  kvant[, c(2, 3, 4)],
  cex.axis = 0.8,
  main = "Boxplot svih BMI podataka"
)

# Python
import matplotlib.pyplot as plt

# Podaci o BMI
bmi_data = kvant[:, [1, 2, 3]]  # Zamijenite ovo sa stvarnim podacima

# Postavite odgovarajuće margine za grafikon
plt.figure(figsize=(6, 3))  # Veličina grafikona
plt.style.use('ggplot')

# Nacrtajte boxplot za odabrane kolone
plt.boxplot(bmi_data, vert=False, widths=0.6, patch_artist=True)
plt.title('Boxplot svih BMI podataka', fontsize=14)
plt.xlabel('BMI', fontsize=12)
plt.yticks([])  # Uklonite oznake s y-ose

plt.show()

# R 
Možemo prikazati i sva 3 boxplota 1 do drugog da bude preglednije
# Postavite raspored za prikaz boxplotova
par(mfrow = c(1, 3))

# Nacrtajte boxplot za visinu
boxplot(
  kvant$Visina,
  main = "Visina"
)

# Nacrtajte boxplot za težinu
boxplot(
  kvant$Tezina,
  main = "Težina"
)

# Nacrtajte boxplot za BMI
boxplot(
  kvant$BMI,
  main = "BMI"
)

# Python
import matplotlib.pyplot as plt

# Podaci za boxplotove
visina_data = kvant['Visina']  # Zamijenite ovo sa stvarnim podacima
tezina_data = kvant['Tezina']  # Zamijenite ovo sa stvarnim podacima
bmi_data = kvant['BMI']  # Zamijenite ovo sa stvarnim podacima

# Postavite raspored za prikaz boxplotova
plt.figure(figsize=(12, 4))  # Veličina grafikona
plt.style.use('ggplot')

# Nacrtajte boxplot za visinu
plt.subplot(131)
plt.boxplot(visina_data, vert=False, widths=0.6, patch_artist=True)
plt.title('Visina')

# Nacrtajte boxplot za težinu
plt.subplot(132)
plt.boxplot(tezina_data, vert=False, widths=0.6, patch_artist=True)
plt.title('Težina')

# Nacrtajte boxplot za BMI
plt.subplot(133)
plt.boxplot(bmi_data, vert=False, widths=0.6, patch_artist=True)
plt.title('BMI')

plt.tight_layout()  # Organizira panel
plt.show()

# R
Koeficijent korelacije
U R-u je implementirana funkcija cor() koja računa korelaciju 2 niza brojeva
# Primjer korištenja funkcije cor() za izračunavanje koeficijenta korelacije
xv <- c(-2, 0, 2, 4, 4)
yv <- c(2, 2, 3, 4, 4)
cor(xv, yv)

Rezultat:   0.958706

# Python
import numpy as np

# Primjer korištenja funkcije corrcoef() za izračunavanje koeficijenta korelacije
xv = np.array([-2, 0, 2, 4, 4])
yv = np.array([2, 2, 3, 4, 4])

correlation_coefficient = np.corrcoef(xv, yv)[0, 1]
print("Rezultat:", correlation_coefficient)

# R
# Učitavanje podataka za težinu, visinu i indeks tjelesne mase
kvant$Tezina <- c(60, 80, 85, 84, 62, 65, 86, 86, 95, 78, 70, 68)
kvant$Visina <- c(165, 180, 175, 184, 168, 175, 184, 192, 182, 178, 175, 170)
kvant$BMI <- c(22.03857, 24.69136, 27.75510, 24.81096, 21.96712, 21.22449, 25.40170, 23.32899, 28.68011, 24.61810, 22.85714, 23.52941)

# Izračunajte korelaciju između visine i BMI
correlation_height_bmi <- cor(kvant$Visina, kvant$BMI)
cat("Korelacija između visine i BMI:", correlation_height_bmi, "\n")

# Izračunajte korelaciju između visine i težine
correlation_height_weight <- cor(kvant$Visina, kvant$Tezina)
cat("Korelacija između visine i težine:", correlation_height_weight, "\n")

# Python
import numpy as np

# Učitavanje podataka za težinu, visinu i indeks tjelesne mase
tezina = np.array([60, 80, 85, 84, 62, 65, 86, 86, 95, 78, 70, 68])
visina = np.array([165, 180, 175, 184, 168, 175, 184, 192, 182, 178, 175, 170])
bmi = np.array([22.03857, 24.69136, 27.75510, 24.81096, 21.96712, 21.22449, 25.40170, 23.32899, 28.68011, 24.61810, 22.85714, 23.52941])

# Izračunajte korelaciju između visine i BMI
correlation_height_bmi = np.corrcoef(visina, bmi)[0, 1]
print("Korelacija između visine i BMI:", correlation_height_bmi)

# Izračunajte korelaciju između visine i težine
correlation_height_weight = np.corrcoef(visina, tezina)[0, 1]
print("Korelacija između visine i težine:", correlation_height_weight)

# R
# Prikaz zavisnosti između visine i BMI korištenjem scatterplot-a
par(mar = c(2, 2, 2, 1))
plot(
  kvant$Visina,
  kvant$BMI,
  main = "Visina i BMI",
  cex.axis = 0.8,
  cex.main = 0.8
)

# Python
import matplotlib.pyplot as plt

# Prikaz zavisnosti između visine i BMI korištenjem scatterplot-a
plt.figure(figsize=(6, 4))  # Veličina grafikona
plt.style.use('ggplot')

plt.scatter(kvant['Visina'], kvant['BMI'], marker='o', s=40)
plt.title("Visina i BMI")
plt.xlabel("Visina")
plt.ylabel("BMI")

plt.show()

# R
# Možemo iskoristiti funkciju pairs() za prikaz grafova zavisnosti između kvantitativnih nizova
# Na primjer, za prikaz zavisnosti visine, težine i BMI

pairs(
  kvant[, c(3, 4, 5)],
  main = "Zavisnost između visine, težine i BMI",
  pch = 19,  # Veličina točaka
  cex.labels = 1.5,  # Veličina oznaka
  cex.axis = 1.2  # Veličina oznaka osi
)

# Python
import seaborn as sns
import matplotlib.pyplot as plt

# Možemo iskoristiti pairplot za prikaz grafova zavisnosti između kvantitativnih nizova
# Na primjer, za prikaz zavisnosti visine, težine i BMI

data = kvant[['Visina', 'Tezina', 'BMI']]
sns.set(style="ticks")
sns.pairplot(data, markers='o', plot_kws={'s': 40})
plt.suptitle("Zavisnost između visine, težine i BMI", y=1.02)

plt.show()

# R
# Učitavanje podataka iz Excel datoteke "Skok-u-dalj.xlsx" u varijablu "dalj"
dalj <- read.xlsx("Skok-u-dalj.xlsx", sheetName = "Skok-u-dalj", header = FALSE)

# Python
Da bismo u Pythonu učitali Excel datoteku, koristimo Pandas paket
import pandas as pd

# Učitavanje podataka iz Excel datoteke "Skok-u-dalj.xlsx" u DataFrame "dalj"
dalj = pd.read_excel("Skok-u-dalj.xlsx", sheet_name="Skok-u-dalj", header=None)

# R
U R-u možemo i pridružiti imena stupcima
# Pridruživanje imena stupcima DataFrame-a "dalj"
names(dalj) <- c("daljina", "ime", "prezime", "rodjenje", "klub", "dat_skok")

# Python
# Pridruživanje imena stupcima DataFrame-a "dalj"
dalj.columns = ["daljina", "ime", "prezime", "rodjenje", "klub", "dat_skok"]

# R
U ovom kontekstu, imamo jedan numerički vektor koji sadrži ukupno 30 podataka. Stupci "rodjenje" i "dat_skok" predstavljaju datume, što znači da se mogu urediti i sortirati. Na primjer, možemo sortirati stupac "rodjenje" kako bismo dobili podatke u određenom redoslijedu, kao što je prikazano u sljedećem R kodu:
# Sortiranje stupca "rodjenje" u DataFrame-u "dalj"
sorted_dalj <- dalj[order(dalj$rodjenje), ]
Sortirati će se datumi rođenja uzlazno i dati nam uredan pregled nad podacima

# Python
U ovom kontekstu, imamo jedan numerički vektor koji sadrži ukupno 30 podataka. Stupci "rodjenje" i "dat_skok" predstavljaju datume, što znači da se mogu urediti i sortirati. Na primjer, možemo sortirati stupac "rodjenje" kako bismo dobili podatke u određenom redoslijedu, kao što je prikazano u sljedećem Python kodu:
# Sortiranje stupca "rodjenje" u DataFrame-u "dalj"
sorted_dalj = dalj.sort_values(by="rodjenje")

# R
# Ispis sažetka podataka za DataFrame "dalj"
summary(dalj)

# Dobivena tablica sa sređenim formatiranjem
# ------------------------------------------------------------------------------------------------------------------------------
#       daljina              ime                   prezime                 rodjenje        klub              dat_skok   
# Length:30          Length:30          Length:30          Length:30          Length:30          Length:30         
# Class :character   Class :character   Class :character   Class :character   Class :character   Class :character  
# Mode  :character   Mode  :character   Mode  :character   Mode  :character   Mode  :character   Mode  :character  
# ------------------------------------------------------------------------------------------------------------------------------
#       Min.             :5.420   Min.   :5.518   Min.   :5.850   Min.   :2003-03-31   Min.   :2022-04-30  
# 1st Qu.:5.518   1st Qu.:5.518   1st Qu.:5.850   1st Qu.:2004-07-22   1st Qu.:2022-05-22  
# Median :5.850   Median :5.518   Median :5.850   Median :2006-09-06   Median :2022-06-19  
# Mean   :5.969   Mean   :5.518   Mean   :5.850   Mean   :2006-01-27   Mean   :2022-07-10  
# 3rd Qu.:6.050   3rd Qu.:5.518   3rd Qu.:5.850   3rd Qu.:2007-05-04   3rd Qu.:2022-09-11  
# Max.   :7.510   Max.   :5.518   Max.   :5.850   Max.   :2009-03-10   Max.   :2022-09-20  
# ------------------------------------------------------------------------------------------------------------------------------

# Python
import pandas as pd

# Prikaz sažetka podataka za DataFrame "dalj"
summary_dalj = dalj.describe(include="all")

# Ispis tablice srednjim formatiranjem
print(summary_dalj.to_markdown())

Ovaj Python kod koristi funkciju describe() za prikaz sažetka podataka u DataFrame dalj, a zatim koristi to_markdown() metodu kako bi ispisao tablicu sa srednjim formatiranjem.

# R
# Postavljanje margina za grafikon
par(mar = c(2, 2, 2, 1))

# Nacrtajte boxplot za stupac "daljina" u DataFrame-u "dalj"
boxplot(
  dalj$daljina,
  cex.axis = 0.8,
  main = "Boxplot preskočene daljine"
)

# Python
import matplotlib.pyplot as plt

# Postavljanje margina za grafikon
plt.figure(figsize=(5, 5))
plt.margins(0.2)

# Nacrtajte boxplot za stupac "daljina" u DataFrame "dalj"
plt.boxplot(dalj["daljina"], vert=False)
plt.title("Boxplot preskočene daljine")

plt.show()

# R
# Postavljanje margina za grafikon
par(mar = c(4, 4, 2, 1))

# Nacrtajte histogram za stupac "daljina" u DataFrame-u "dalj"
hist(
  dalj$daljina,
  main = "Histogram duljine skoka",
  xlab = "Daljina",
  ylab = "Frekvencija",
  las = 1,
  cex.axis = 0.8,
  col = "darkmagenta"
)

# Python
import matplotlib.pyplot as plt

# Postavljanje margina za grafikon
plt.figure(figsize=(4, 4))
plt.subplots_adjust(left=0.2, right=0.9, top=0.9, bottom=0.2)

# Nacrtajte histogram za stupac "daljina" u DataFrame "dalj"
plt.hist(dalj["daljina"], bins=10, color="darkmagenta")
plt.title("Histogram duljine skoka")
plt.xlabel("Daljina")
plt.ylabel("Frekvencija")

plt.show()

# R
# Postavljanje margina za grafikon
par(mar = c(4, 4, 2, 1))

# Nacrtajte histogram za stupac "daljina" u DataFrame-u "dalj"
hist(
  dalj$daljina,
  main = "Histogram duljine skoka",
  xlab = "Daljina",
  ylab = "Frekvencija",
  breaks = 15,
  las = 1,
  cex.axis = 0.8,
  cex.main = 0.8,
  col = "darkmagenta"
)
# Python
import matplotlib.pyplot as plt

# Postavljanje margina za grafikon
plt.figure(figsize=(4, 4))
plt.subplots_adjust(left=0.2, right=0.9, top=0.9, bottom=0.2)

# Nacrtajte histogram za stupac "daljina" u DataFrame "dalj"
plt.hist(dalj["daljina"], bins=15, color="darkmagenta")
plt.title("Histogram duljine skoka")
plt.xlabel("Daljina")
plt.ylabel("Frekvencija")

plt.show()

# R
# Grupiranje duljine skoka prema klubovima i prikaz sažetka za svaku grupu
by(dalj$daljina, dalj["klub"], summary)

# Python
import pandas as pd

# Grupiranje duljine skoka prema klubovima i prikaz sažetka za svaku grupu
grouped = dalj.groupby("klub")
summary = grouped["daljina"].describe()
print(summary)

# R
# Izdvajamo natjecatelje iz Zagreba
dalj.zg <- dalj[dalj$klub == "Zagreb", ]

# Izdvajamo natjecatelje iz Rijeke
dalj.ri <- dalj[dalj$klub == "Rijeka", ]

# Izdvajamo natjecatelje iz Varaždina
dalj.vz <- dalj[dalj$klub == "Varaždin", ]

# Postavljamo margine za grafikone
par(mar = c(2, 2, 2, 1))

# Postavljamo raspored za prikaz boxplotova
par(mfrow = c(1, 3))

# Crtamo boxplot za natjecatelje iz Zagreba
boxplot(
  dalj.zg$daljina,
  main = "Zagreb"
)

# Crtamo boxplot za natjecatelje iz Rijeke
boxplot(
  dalj.ri$daljina,
  main = "Rijeka"
)

# Crtamo boxplot za natjecatelje iz Varaždina
boxplot(
  dalj.vz$daljina,
  main = "Varaždin"
)

# Python
import matplotlib.pyplot as plt

# Izdvajamo natjecatelje iz Zagreba
dalj_zg = dalj[dalj["klub"] == "Zagreb"]

# Izdvajamo natjecatelje iz Rijeke
dalj_ri = dalj[dalj["klub"] == "Rijeka"]

# Izdvajamo natjecatelje iz Varaždina
dalj_vz = dalj[dalj["klub"] == "Varaždin"]

# Postavljanje margina za grafikone
plt.subplots(figsize=(12, 4))
plt.subplots_adjust(wspace=0.4)

# Crtamo boxplot za natjecatelje iz Zagreba
plt.subplot(131)
plt.boxplot(dalj_zg["daljina"], vert=False)
plt.title("Zagreb")
plt.xlabel("Daljina")

# Crtamo boxplot za natjecatelje iz Rijeke
plt.subplot(132)
plt.boxplot(dalj_ri["daljina"], vert=False)
plt.title("Rijeka")
plt.xlabel("Daljina")

# Crtamo boxplot za natjecatelje iz Varaždina
plt.subplot(133)
plt.boxplot(dalj_vz["daljina"], vert=False)
plt.title("Varaždin")
plt.xlabel("Daljina")

plt.show()
